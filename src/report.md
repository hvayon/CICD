## Part 1. Настройка gitlab-runner

* Поднимаем виртуальную машину *Ubuntu Server 20.04 LTS*

![image](img/Ubuntu_20.04.5.png)

* Скачиваем и установливаем на виртуальную машину **gitlab-runner**

![image](img/gitlab-runner_install.png)

* Включаем и запускаем **gitlab-runner**

![image](img/gitlab-runner_start.png)

![image](img/sudo_systemctl.png)

* Зарегистрируем его для использования в текущем проекте (DO6_CICD)

![image](img/gitlab-runner_register.png)

## Part 2. Сборка

**Написать этап для CI по сборке приложений из проекта *C2_SimpleBashUtils***
* В файле *gitlab-ci.yml* добавляем этап запуска сборки через Makefile из проекта C2
* Файлы, полученные после сборки (артефакты), сохраняем в произвольную директорию на 30 дней.

![image](img/gitlab-ci.png)

* Результат сборки:

![image](img/build-code-job.png)

## Part 3. Тест кодстайла

**Написать этап для CI, который запускает скрипт кодстайла (*clang-format*)**

* В файле *gitlab-ci.yml* добавляем этап проверки codestyle, если он не отработает корректно, но пайплайн будет зафейлен
* В пайплайне отображаем вывод утилиты *clang-format*

![image](img/codestyle_yml.png)

* Результат сборки:

![image](img/style_job.png)

## Part 4. Интеграционные тесты

**Написать этап для CI, который запускает ваши интеграционные тесты из того же проекта:**

* Запускаем этот этап автоматически только при условии, что сборка и тест codestyle прошли успешно

* Если тесты не прошли, то пайплайн будет зайфейлен

* В пайплайне отобразить вывод, что интеграционные тесты успешно прошли / провалились

![image](img/test_yml.png)

Результат сборки:

![image](img/test_code_1.png)

![image](img/test_code_2.png)

## Part 5. Этап деплоя

* Поднять вторую виртуальную машину *Ubuntu Server 20.04 LTS*

![image](img/ubuntu_server_2.png)

* Пробрасываем маршрут от машине к машине с помощью конфигурационных файлов *netplan.yml*
	* Первая машина
	![image](img/netplan_1.png)
	* Вторая машина
	![image](img/netplan_2.png)
enp0s8 - виртуальный адаптер хоста

* Пишем скрипт  который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию /usr/local/bin второй виртуальной машины

* Используем утилиту **expect**, которая позволяет создавать программы, ожидающие вопросов от других программ и дающие им ответы. Скрипт копирует артифакты из одной машины в другую.

* Дописываем в файл *.gitlab-ci.yml* этап дейплоя

![image](img/deploy.png)

* Этот этап запускается вручную при условии, что все предыдущие этапы прошли успешно

* Результат работы:

![image](img/deploy_job.png)

## Part 6. Дополнительно. Уведомления

* Создаем telegram-бота с помощью @BotFather

* Получаем токен бота и используем его в нашем скрипте из materials/notification.md

* Добавляем идентификатор профиля telegram и job_status ($CI_JOB_STATUS) в скрипт

* После каждой джобы прописываем запуск скрипта *notify.sh* в файле *.gitlab-ci.yml*

![image](img/notify.png)

* Скрипт присылает уведомления об успешном/неуспешном выполнении пайплайна через бота с именем "hvayon DO6 CI/CD" в Telegram

![image](img/telegram.png)